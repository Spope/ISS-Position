function initScene(){Detector.webgl||Detector.addGetWebGLMessage({parent:document.getElementById("canvas")}),scene=new THREE.Scene;var e=$(window).width(),t=Math.round(.8*$(window).height());(camera=new THREE.PerspectiveCamera(60,e/t,.1,1e6)).position.set(0,0,300),(renderer=new THREE.WebGLRenderer({alpha:!0})).setSize(e,t),renderer.setClearColorHex(0,1),document.getElementById("canvas").appendChild(renderer.domElement),(sun=new THREE.DirectionalLight(16777215,3)).position.set(0,0,6e4),scene.add(sun),(controls=new THREE.OrbitControls(camera,renderer.domElement)).minDistance=180,controls.maxDistance=2e4,controls.noPan=!0,window.addEventListener("resize",onWindowResize),createSatellite(),createEarth(),createMoon(),createLensFlare(),createUniverse(),updateEarthAngle(),updateSatPosition(),updateMoonPosition(),render()}function onWindowResize(){var e=$(window).width(),t=Math.round(.8*$(window).height());renderer.setSize(e,t),camera.aspect=e/t,camera.updateProjectionMatrix()}function createEarth(){var e={Kr:.0025,Km:.001,ESun:20,g:-.95,innerRadius:100,cloudRadius:100*1.003,outerRadius:100*1.025,wavelength:[.65,.57,.475],scaleDepth:.25,mieScaleDepth:.1},t=THREE.ImageUtils.loadTexture("img/earth/EarthMapAtmos_2500x1250.jpg"),n=THREE.ImageUtils.loadTexture("img/earth/earthNight.jpg"),a=THREE.ImageUtils.loadTexture("img/earth/EarthMask_2500x1250.jpg"),o=THREE.ImageUtils.loadTexture("img/earth/cloudAlpha.png"),i=renderer.getMaxAnisotropy();t.anisotropy=i,n.anisotropy=i,a.anisotropy=i,o.anisotropy=i,uniforms={v3LightPosition:{type:"v3",value:new THREE.Vector3(1e8,0,0).normalize()},v3InvWavelength:{type:"v3",value:new THREE.Vector3(1/Math.pow(e.wavelength[0],4),1/Math.pow(e.wavelength[1],4),1/Math.pow(e.wavelength[2],4))},fCameraHeight:{type:"f",value:0},fCameraHeight2:{type:"f",value:0},fInnerRadius:{type:"f",value:e.innerRadius},fInnerRadius2:{type:"f",value:e.innerRadius*e.innerRadius},fCloudRadius:{type:"f",value:e.cloudRadius},fCloudRadius2:{type:"f",value:e.cloudRadius*e.cloudRadius},fOuterRadius:{type:"f",value:e.outerRadius},fOuterRadius2:{type:"f",value:e.outerRadius*e.outerRadius},fKrESun:{type:"f",value:e.Kr*e.ESun},fKmESun:{type:"f",value:e.Km*e.ESun},fKr4PI:{type:"f",value:4*e.Kr*Math.PI},fKm4PI:{type:"f",value:4*e.Km*Math.PI},fScale:{type:"f",value:1/(e.outerRadius-e.innerRadius)},fScaleDepth:{type:"f",value:e.scaleDepth},fScaleOverScaleDepth:{type:"f",value:1/(e.outerRadius-e.innerRadius)/e.scaleDepth},g:{type:"f",value:e.g},g2:{type:"f",value:e.g*e.g},nSamples:{type:"i",value:3},fSamples:{type:"f",value:3},tDiffuse:{type:"t",value:t},tDiffuseCloud:{type:"t",value:o},tDiffuseNight:{type:"t",value:n},tDisplacement:{type:"t",value:0},tSkyboxDiffuse:{type:"t",value:0},fNightScale:{type:"f",value:1},tSpecular:{type:"t",value:a}},(ground={geometry:new THREE.SphereGeometry(e.innerRadius,50,50),material:new THREE.ShaderMaterial({uniforms:uniforms,vertexShader:vertexGround,fragmentShader:fragmentGround})}).mesh=new THREE.Mesh(ground.geometry,ground.material),ground.mesh.castShadow=!0,ground.mesh.receiveShadow=!0,scene.add(ground.mesh);(sky={geometry:new THREE.SphereGeometry(e.outerRadius,150,150),material:new THREE.ShaderMaterial({uniforms:uniforms,vertexShader:vertexSky,fragmentShader:fragmentSky})}).mesh=new THREE.Mesh(sky.geometry,sky.material),ground.mesh.castShadow=!0,ground.mesh.receiveShadow=!0,sky.material.side=THREE.BackSide,sky.material.transparent=!0,scene.add(sky.mesh),(cloud={geometry:new THREE.SphereGeometry(e.cloudRadius,50,50),material:new THREE.ShaderMaterial({uniforms:uniforms,vertexShader:vertexCloud,fragmentShader:fragmentCloud})}).mesh=new THREE.Mesh(cloud.geometry,cloud.material),cloud.material.transparent=!0,cloud.material.blending=THREE.AdditiveBlending,scene.add(cloud.mesh)}function createMoon(){(moon={geometry:new THREE.SphereGeometry(27.2,32,32),material:new THREE.MeshLambertMaterial}).material.map=THREE.ImageUtils.loadTexture("img/moonmap.jpg"),moon.mesh=new THREE.Mesh(moon.geometry,moon.material),scene.add(moon.mesh),moon.mesh.position.set(0,0,0)}function createSatellite(){(sat={geometry:new THREE.SphereGeometry(1,10,10),material:new THREE.MeshBasicMaterial({color:65280})}).mesh=new THREE.Mesh(sat.geometry,sat.material),scene.add(sat.mesh)}function createUniverse(){var e=THREE.ImageUtils.loadTexture("img/galaxy.jpg"),t={geometry:new THREE.SphereGeometry(5e5,32,32),material:new THREE.MeshBasicMaterial};t.material.map=e,t.material.side=THREE.BackSide,t.mesh=new THREE.Mesh(t.geometry,t.material),scene.add(t.mesh)}function createLensFlare(){var e=THREE.ImageUtils.loadTexture("img/lensflare/lensflare0.png"),t=THREE.ImageUtils.loadTexture("img/lensflare/lensflare2.png"),n=THREE.ImageUtils.loadTexture("img/lensflare/lensflare3.png"),a=new THREE.Color(16777215);a.setHSL(.55,.9,1),(lensFlare=new THREE.LensFlare(e,700,0,THREE.AdditiveBlending,a)).add(t,512,0,THREE.AdditiveBlending),lensFlare.add(t,512,0,THREE.AdditiveBlending),lensFlare.add(t,512,0,THREE.AdditiveBlending),lensFlare.add(n,60,.6,THREE.AdditiveBlending),lensFlare.add(n,70,.7,THREE.AdditiveBlending),lensFlare.add(n,120,.9,THREE.AdditiveBlending),lensFlare.add(n,70,1,THREE.AdditiveBlending),lensFlare.position.set(0,0,500),scene.add(lensFlare)}function setXYZ(){var e=new THREE.LineBasicMaterial({color:11862037}),t=new THREE.Geometry;t.vertices.push(new THREE.Vector3(0,0,0));var n={1:-23.44,2:-15.53,3:-7.62,4:.29,5:7.62,6:15.53,7:23.44,8:15.53,9:7.62,10:-.29,11:-7.62,12:-15.53}[(new Date).getMonth()+1],a=24e4*Math.cos(2*n*Math.PI/360),o=24e4*Math.sin(2*n*Math.PI/360),i=0;t.vertices.push(new THREE.Vector3(a,o,i));var r=new THREE.Line(t,e);scene.add(r);var l=new THREE.LineBasicMaterial({color:11862037}),s=new THREE.Geometry;s.vertices.push(new THREE.Vector3(0,0,0)),s.vertices.push(new THREE.Vector3(150,0,0));a=new THREE.Line(s,l);scene.add(a);var f=new THREE.LineBasicMaterial({color:817664}),u=new THREE.Geometry;u.vertices.push(new THREE.Vector3(0,0,0)),u.vertices.push(new THREE.Vector3(0,150,0));o=new THREE.Line(u,f);scene.add(o);var c=new THREE.LineBasicMaterial({color:327836}),h=new THREE.Geometry;h.vertices.push(new THREE.Vector3(0,0,0)),h.vertices.push(new THREE.Vector3(0,0,150));i=new THREE.Line(h,c);scene.add(i)}function updateEarthAngle(){var e=Math.PI/12/60/60,t=new Date,n=new Date(t.valueOf()+6e4*t.getTimezoneOffset()),a=n.getMinutes(),o=n.getHours(),i=n.getSeconds()+60*a+60*o*60,r=Math.PI-e*i;eurlerLight=new THREE.Euler(0,r,0);var l=getTodayEarthAngle(),s=r+Math.PI/2,f=24e4*Math.sin(s),u=24e4*Math.cos(s),c=24e4*Math.sin(2*l*Math.PI/360);lensFlare.position.set(f,c,u),sun.position.set(f,c,u),setTimeout(updateEarthAngle,3e3)}function getTodayEarthAngle(){var e=new Date,t=e-new Date(e.getFullYear(),0,0),n=Math.floor(t/864e5);return 180*Math.asin(Math.sin(Math.PI/180*23.45)*Math.sin(360/365*(n-81)*(Math.PI/180)))/Math.PI}function render(){var e,t,n,a;requestAnimationFrame(render),controls.update();var o=getTodayEarthAngle(),i=Math.sin(2*o*Math.PI/360);return a=new THREE.Vector3(1,i,0),n=(new THREE.Matrix4).makeRotationFromEuler(eurlerLight),t=a.applyProjection(n),e=camera.position.length(),sky.material.uniforms.v3LightPosition.value=t,sky.material.uniforms.fCameraHeight.value=e,sky.material.uniforms.fCameraHeight2.value=e*e,ground.material.uniforms.v3LightPosition.value=t,ground.material.uniforms.fCameraHeight.value=e,ground.material.uniforms.fCameraHeight2.value=e*e,cloud.material.uniforms.v3LightPosition.value=t,cloud.material.uniforms.fCameraHeight.value=e,cloud.material.uniforms.fCameraHeight2.value=e*e,renderer.render(scene,camera)}function drawOrbit(e){var t=new THREE.LineBasicMaterial({color:11862037}),n=new THREE.Geometry;for(var a in e)n.vertices.push(new THREE.Vector3(e[a].x,e[a].y,e[a].z));var o=new THREE.Line(n,t);scene.add(o)}function updateSatPosition(){if(earthPositionData){var e=interpolatePosition(earthPositionData,earthReceivedDate);sat.mesh.position.set(e.x,e.y,e.z)}setTimeout(updateSatPosition,100)}function satPosition(e){earthPositionData=e,earthReceivedDate=new Date,sat.mesh.position.set(e[0].x,e[0].y,e[0].z),drawOrbit(e)}function moonPosition(e){moonPositionData=e,moonReceivedDate=new Date,moon.mesh.position.set(e[0].x,e[0].y,e[0].z)}function updateMoonPosition(){if(moonPositionData){var e=interpolatePosition(moonPositionData,moonReceivedDate);moon.mesh.position.set(e.x,e.y,e.z)}setTimeout(updateMoonPosition,200)}function interpolatePosition(e,t){new Date(e[0].time);var n=new Date,a=n.getSeconds(),o=n.getMilliseconds(),i=n.getMinutes()-t.getMinutes(),r=e[i+=60*(n.getHours()-t.getHours())],l=e[i+1];r||(console.error("No data for current"),console.log(i),console.log(r)),l||(console.error("No data for next"),console.log(i+1),console.log(l));var s=(l.x-r.x)/60,f=(l.y-r.y)/60,u=(l.z-r.z)/60,c=s/1e3,h=f/1e3,d=u/1e3,m={};return m.x=r.x+s*a+c*o,m.y=r.y+f*a+h*o,m.z=r.z+u*a+d*o,m}function bindScrollBtn(e){document.getElementById("btn-bottom").onclick=function(){scrollTo(document.body,e,500)}}function setImg(e){document.getElementById("img-scroll").src="img/"+e}function scrollTo(e,t,n){var a=window.scrollY,o=t-a,i=0,r=function(){i+=20;var e=Math.easeInOutQuad(i,a,o,n);console.log(e),window.scroll(0,e),i<n&&setTimeout(r,20)};r()}function debounce(e,t,n){var a;return function(){var o=this,i=arguments,r=n&&!a;clearTimeout(a),a=setTimeout(function(){a=null,n||e.apply(o,i)},t),r&&e.apply(o,i)}}var vertexSky="//\n// Atmospheric scattering vertex shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\nuniform vec3 v3LightPosition;\t// The direction vector to the light source\nuniform vec3 v3InvWavelength;\t// 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;\t// The camera's current height\nuniform float fCameraHeight2;\t// fCameraHeight^2\nuniform float fOuterRadius;\t\t// The outer (atmosphere) radius\nuniform float fOuterRadius2;\t// fOuterRadius^2\nuniform float fInnerRadius;\t\t// The inner (planetary) radius\nuniform float fInnerRadius2;\t// fInnerRadius^2\nuniform float fKrESun;\t\t\t// Kr * ESun\nuniform float fKmESun;\t\t\t// Km * ESun\nuniform float fKr4PI;\t\t\t// Kr * 4 * PI\nuniform float fKm4PI;\t\t\t// Km * 4 * PI\nuniform float fScale;\t\t\t// 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;\t\t// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth;\t// fScale / fScaleDepth\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\n\nfloat scale(float fCos)\n{\n    float x = 1.0 - fCos;\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n    vec3 v3Ray = position - cameraPosition;\n    float fFar = length(v3Ray);\n    v3Ray /= fFar;\n\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n    float B = 2.0 * dot(cameraPosition, v3Ray);\n    float C = fCameraHeight2 - fOuterRadius2;\n    float fDet = max(0.0, B*B - 4.0 * C);\n    float fNear = 0.5 * (-B - sqrt(fDet));\n\n    // Calculate the ray's starting position, then calculate its scattering offset\n    vec3 v3Start = cameraPosition + v3Ray * fNear;\n    fFar -= fNear;\n    float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n    float fStartDepth = exp(-1.0 / fScaleDepth);\n    float fStartOffset = fStartDepth * scale(fStartAngle);\n    //c0 = vec3(1.0, 0, 0) * fStartAngle;\n\n    // Initialize the scattering loop variables\n    float fSampleLength = fFar / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = v3Ray * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n    //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Now loop through the sample rays\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<nSamples; i++)\n    {\n        float fHeight = length(v3SamplePoint);\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n        float fLightAngle = dot(v3LightPosition, v3SamplePoint) / fHeight;\n        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n        float fScatter = (fStartOffset + fDepth * (scale(fLightAngle) - scale(fCameraAngle)));\n        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n        v3SamplePoint += v3SampleRay;\n    }\n\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    c0 = v3FrontColor * (v3InvWavelength * fKrESun);\n    c1 = v3FrontColor * fKmESun;\n    v3Direction = cameraPosition - position;\n}",fragmentSky="//\n    // Atmospheric scattering fragment shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n\n    uniform vec3 v3LightPos;\n    uniform float g;\n    uniform float g2;\n\n    varying vec3 v3Direction;\n    varying vec3 c0;\n    varying vec3 c1;\n\n    // Calculates the Mie phase function\n    float getMiePhase(float fCos, float fCos2, float g, float g2)\n    {\n        return 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(1.0 + g2 - 2.0 * g * fCos, 1.5);\n    }\n\n    // Calculates the Rayleigh phase function\n    float getRayleighPhase(float fCos2)\n    {\n        return 0.75 + 0.75 * fCos2;\n    }\n\n    void main (void)\n    {\n        float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);\n        float fCos2 = fCos * fCos;\n\n        vec3 color =\tgetRayleighPhase(fCos2) * c0 +\n                        getMiePhase(fCos, fCos2, g, g2) * c1;\n\n        gl_FragColor = vec4(color, 1.0);\n        gl_FragColor.a = gl_FragColor.b;\n   }",vertexGround="//\n    // Atmospheric scattering vertex shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // Ported for use with three.js/WebGL by James Baicoianu\n\n    uniform vec3 v3LightPosition;\t\t// The direction vector to the light source\n    uniform vec3 v3InvWavelength;\t// 1 / pow(wavelength, 4) for the red, green, and blue channels\n    uniform float fCameraHeight;\t// The camera's current height\n    uniform float fCameraHeight2;\t// fCameraHeight^2\n    uniform float fOuterRadius;\t\t// The outer (atmosphere) radius\n    uniform float fOuterRadius2;\t// fOuterRadius^2\n    uniform float fInnerRadius;\t\t// The inner (planetary) radius\n    uniform float fInnerRadius2;\t// fInnerRadius^2\n    uniform float fKrESun;\t\t\t// Kr * ESun\n    uniform float fKmESun;\t\t\t// Km * ESun\n    uniform float fKr4PI;\t\t\t// Kr * 4 * PI\n    uniform float fKm4PI;\t\t\t// Km * 4 * PI\n    uniform float fScale;\t\t\t// 1 / (fOuterRadius - fInnerRadius)\n    uniform float fScaleDepth;\t\t// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n    uniform float fScaleOverScaleDepth;\t// fScale / fScaleDepth\n    uniform sampler2D tDiffuse;\n\n    varying vec3 v3Direction;\n    varying vec3 c0;\n    varying vec3 c1;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec2 testCoord;\n\n    const int nSamples = 3;\n    const float fSamples = 3.0;\n\n    float scale(float fCos)\n    {\n        float x = 1.0 - fCos;\n        return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n    }\n\n    void main(void)\n    {\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = position - cameraPosition;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n        // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n        float B = 2.0 * dot(cameraPosition, v3Ray);\n        float C = fCameraHeight2 - fOuterRadius2;\n        float fDet = max(0.0, B*B - 4.0 * C);\n        float fNear = 0.5 * (-B - sqrt(fDet));\n\n        // Calculate the ray's starting position, then calculate its scattering offset\n        vec3 v3Start = cameraPosition + v3Ray * fNear;\n        fFar -= fNear;\n        float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n        float fCameraAngle = dot(-v3Ray, position) / length(position);\n        float fLightAngle = dot(v3LightPosition, position) / length(position);\n        float fCameraScale = scale(fCameraAngle);\n        float fLightScale = scale(fLightAngle);\n        float fCameraOffset = fDepth*fCameraScale;\n        float fTemp = (fLightScale + fCameraScale);\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n        vec3 v3Attenuate;\n        for(int i=0; i<nSamples; i++)\n        {\n            float fHeight = length(v3SamplePoint);\n            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n            float fScatter = fDepth*fTemp - fCameraOffset;\n            v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n            v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n            v3SamplePoint += v3SampleRay;\n        }\n\n        // Calculate the attenuation factor for the ground\n        c0 = v3Attenuate;\n        c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      //testCoord = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n        //gl_TexCoord[0] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n        //gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n      vUv = uv;\n      vNormal = normal;\n    }",fragmentGround="//\n    // Atmospheric scattering fragment shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // Ported for use with three.js/WebGL by James Baicoianu\n\n    uniform float fNightScale;\n    uniform vec3 v3LightPosition;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDiffuseNight;\n    uniform sampler2D tSpecular;\n\n\n    varying vec3 c0;\n    varying vec3 c1;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 v3Direction;\n\n    void main (void)\n    {\n        //Spope\n        /*\n        float shininess = (texture2D(tSpecular, vec2(vUv.s, vUv.t)).r * 255.0) + 0.1; // Apparament incorect > le pow() a besoin d'une virgule\n        vec3 reflectionDirection = reflect(-v3LightPosition, vNormal);\n        float specularLightWeighting;\n        specularLightWeighting = pow(max(dot(reflectionDirection, v3Direction), 0.0), shininess);//Shininess 20\n\n        float diffuseLightWeighting = max(dot(vNormal, v3LightPosition), 0.0);\n\n        vec3 uAmbientColor = vec3(1, 1, 1);\n        vec3 uPointLightingSpecularColor = vec3(1, 1, 1);\n        vec3 uPointLightingDiffuseColor = vec3(1, 1, 1);\n\n        vec3 lightWeighting = uAmbientColor\n        + uPointLightingSpecularColor * specularLightWeighting\n        + uPointLightingDiffuseColor * diffuseLightWeighting;\n        \n\n        //vec3 lightWeighting = vec3(1, 1, 1);\n\n        vec4 fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);\n        vec4 temp = vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a);\n\n        //float mid = 0.5;\n        //float vRotation = 1.57;\n        //vec2 rotated = vec2(cos(vRotation) * (gl_PointCoord.x - mid) + sin(vRotation) * (gl_PointCoord.y - mid) + mid,\n            //cos(vRotation) * (gl_PointCoord.y - mid) - sin(vRotation) * (gl_PointCoord.x - mid) + mid);\n\n\n        vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;\n        vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;\n\n        vec3 day = diffuseTex * c0;\n        vec3 night = fNightScale * diffuseNightTex * diffuseNightTex * diffuseNightTex * (1.0 - c0);\n\n        gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);\n        */\n\n        vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;\n        vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;\n\n        vec3 day = diffuseTex * c0;\n        vec3 night = fNightScale * diffuseNightTex * diffuseNightTex * diffuseNightTex * (1.0 - c0);\n\n        gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);\n\n        //ORIGINAL\n        /*\n        vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;\n        vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;\n\n        vec3 day = diffuseTex * c0;\n        vec3 night = fNightScale * diffuseNightTex * diffuseNightTex * diffuseNightTex * (1.0 - c0);\n\n        gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);\n        */\n    }",vertexCloud="//\n    // Atmospheric scattering vertex shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // Ported for use with three.js/WebGL by James Baicoianu\n\n    uniform vec3 v3LightPosition;\t\t// The direction vector to the light source\n    uniform vec3 v3InvWavelength;\t// 1 / pow(wavelength, 4) for the red, green, and blue channels\n    uniform float fCameraHeight;\t// The camera's current height\n    uniform float fCameraHeight2;\t// fCameraHeight^2\n    uniform float fOuterRadius;\t\t// The outer (atmosphere) radius\n    uniform float fOuterRadius2;\t// fOuterRadius^2\n    uniform float fCloudRadius;\t\t// The inner (planetary) radius\n    uniform float fCloudRadius2;\t// fInnerRadius^2\n    uniform float fKrESun;\t\t\t// Kr * ESun\n    uniform float fKmESun;\t\t\t// Km * ESun\n    uniform float fKr4PI;\t\t\t// Kr * 4 * PI\n    uniform float fKm4PI;\t\t\t// Km * 4 * PI\n    uniform float fScale;\t\t\t// 1 / (fOuterRadius - fInnerRadius)\n    uniform float fScaleDepth;\t\t// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n    uniform float fScaleOverScaleDepth;\t// fScale / fScaleDepth\n    uniform sampler2D tDiffuseCloud;\n\n    varying vec3 v3Direction;\n    varying vec3 c0;\n    varying vec3 c1;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec2 testCoord;\n\n    const int nSamples = 3;\n    const float fSamples = 3.0;\n\n    float scale(float fCos)\n    {\n        float x = 1.0 - fCos;\n        return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n    }\n\n    void main(void)\n    {\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = position - cameraPosition;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n        // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n        float B = 2.0 * dot(cameraPosition, v3Ray);\n        float C = fCameraHeight2 - fOuterRadius2;\n        float fDet = max(0.0, B*B - 4.0 * C);\n        float fNear = 0.5 * (-B - sqrt(fDet));\n\n        // Calculate the ray's starting position, then calculate its scattering offset\n        vec3 v3Start = cameraPosition + v3Ray * fNear;\n        fFar -= fNear;\n        float fDepth = exp((fCloudRadius - fOuterRadius) / fScaleDepth);\n        float fCameraAngle = dot(-v3Ray, position) / length(position);\n        float fLightAngle = dot(v3LightPosition, position) / length(position);\n        float fCameraScale = scale(fCameraAngle);\n        float fLightScale = scale(fLightAngle);\n        float fCameraOffset = fDepth*fCameraScale;\n        float fTemp = (fLightScale + fCameraScale);\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n        vec3 v3Attenuate;\n        for(int i=0; i<nSamples; i++)\n        {\n            float fHeight = length(v3SamplePoint);\n            float fDepth = exp(fScaleOverScaleDepth * (fCloudRadius - fHeight));\n            float fScatter = fDepth*fTemp - fCameraOffset;\n            v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n            v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n            v3SamplePoint += v3SampleRay;\n        }\n\n        // Calculate the attenuation factor for the ground\n        c0 = v3Attenuate;\n        c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      //testCoord = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n        //gl_TexCoord[0] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n        //gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n      vUv = uv;\n      vNormal = normal;\n    }",fragmentCloud="//\n    // Atmospheric scattering fragment shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // Ported for use with three.js/WebGL by James Baicoianu\n\n    //uniform sampler2D s2Tex1;\n    //uniform sampler2D s2Tex2;\n\n    uniform float fNightScale;\n    uniform vec3 v3LightPosition;\n    uniform sampler2D tDiffuseCloud;\n\n    varying vec3 c0;\n    varying vec3 c1;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 v3Direction;\n\n    void main (void)\n    {\n        //gl_FragColor = vec4(c0, 1.0);\n        //gl_FragColor = vec4(0.25 * c0, 1.0);\n        //gl_FragColor = gl_Color + texture2D(s2Tex1, gl_TexCoord[0].st) * texture2D(s2Tex2, gl_TexCoord[1].st) * gl_SecondaryColor;\n\n        vec3 diffuseTex = texture2D( tDiffuseCloud, vUv ).xyz;\n\n        vec3 dayCloud = diffuseTex * c0;\n\n        gl_FragColor = vec4(dayCloud, 1.0);\n    }",nasaRequest=function(e,t,n){return'<?xml version="1.0" encoding="UTF-8" standalone="yes"?><DataRequest xmlns="http://sscweb.gsfc.nasa.gov/schema">'+("<TimeInterval><Start>"+start.toISOString()+"</Start><End>"+end.toISOString()+"</End></TimeInterval>")+'<BFieldModel><InternalBFieldModel>IGRF-10</InternalBFieldModel><ExternalBFieldModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Tsyganenko89cBFieldModel"><KeyParameterValues>KP3_3_3</KeyParameterValues></ExternalBFieldModel><TraceStopAltitude>100</TraceStopAltitude></BFieldModel>'+("<Satellites><Id>"+e+"</Id><ResolutionFactor>1</ResolutionFactor></Satellites>")+"<OutputOptions><AllLocationFilters>true</AllLocationFilters><CoordinateOptions><CoordinateSystem>Geo</CoordinateSystem><Component>X</Component></CoordinateOptions><CoordinateOptions><CoordinateSystem>Geo</CoordinateSystem><Component>Y</Component></CoordinateOptions><CoordinateOptions><CoordinateSystem>Geo</CoordinateSystem><Component>Z</Component></CoordinateOptions><MinMaxPoints>2</MinMaxPoints></OutputOptions></DataRequest>"},GetPosition=function(e,t,n,a){this.satId=e,this.earthRadiusKm=63.78,this.sscUrl="https://sscweb.gsfc.nasa.gov/WS/sscr/2/locations",this.callback=a};GetPosition.prototype.request=function(){var e=nasaRequest(this.satId,this.start,this.end);$.ajax({type:"POST",url:this.sscUrl+"",data:e,dataType:"xml",contentType:"application/xml",processData:!1,success:this.displayData.bind(this),error:this.dataError})},GetPosition.prototype.displayData=function(e){"Success"==$(e).find("StatusCode").text()?(e=$.xml2json(e),this.displaySatelliteTrajectory(e)):alert("Request for information from SSC failed.")},GetPosition.prototype.displaySatelliteTrajectory=function(e){var t={},n=e.Result.Data.Time,a=e.Result.Data.Coordinates.X,o=e.Result.Data.Coordinates.Y,i=e.Result.Data.Coordinates.Z;for(var r in n)t[r]={time:n[r],x:a[r]/this.earthRadiusKm,y:i[r]/this.earthRadiusKm,z:-o[r]/this.earthRadiusKm};this.callback(t)},GetPosition.prototype.dataError=function(e,t,n){var a=$.parseXML(e.responseText),o=$(a).find(".ErrorMessage").text(),i=$(a).find(".ErrorDescription").text();alert("Server request error:\n  HTTP error: "+n+"\n  "+o+"\n  "+i)};var start=new Date,end=new Date;end=new Date(end.getTime()+1104e4),$(function(){new GetPosition("iss",start,end,satPosition).request(),new GetPosition("moon",start,end,moonPosition).request()});var camera,render,renderer,scene,uniforms,controls,earthPositionData,earthReceivedDate,moon,moonPositionData,moonReceivedDate,lensFlare,eurlerLight,ground,sky,cloud,sat,sun;initScene();var body=document.body,html=document.documentElement,height=Math.max(body.scrollHeight,body.offsetHeight,html.clientHeight,html.scrollHeight,html.offsetHeight);bindScrollBtn(height),window.onscroll=debounce(function(){window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop?(bindScrollBtn(0),setImg("up.png")):(bindScrollBtn(height),setImg("bottom.png"))},100),Math.easeInOutQuad=function(e,t,n,a){return(e/=a/2)<1?n/2*e*e+t:(e--,-n/2*(e*(e-2)-1)+t)};
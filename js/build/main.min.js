function initScene(){Detector.webgl||Detector.addGetWebGLMessage({parent:document.getElementById("canvas")}),scene=new THREE.Scene;var a=$(window).width(),b=Math.round(.8*$(window).height());camera=new THREE.PerspectiveCamera(60,a/b,.1,1e6),camera.position.set(0,0,300),renderer=new THREE.WebGLRenderer({alpha:!0}),renderer.setSize(a,b),renderer.setClearColorHex(0,1),document.getElementById("canvas").appendChild(renderer.domElement),sun=new THREE.DirectionalLight(16777215,3),sun.position.set(0,0,6e4),scene.add(sun),controls=new THREE.OrbitControls(camera,renderer.domElement),controls.minDistance=180,controls.maxDistance=2e4,controls.noPan=!0,window.addEventListener("resize",onWindowResize),createSatellite(),createEarth(),createMoon(),createLensFlare(),createUniverse(),updateEarthAngle(),updateSatPosition(),updateMoonPosition(),render()}function onWindowResize(){var a=$(window).width(),b=Math.round(.8*$(window).height());renderer.setSize(a,b),camera.aspect=a/b,camera.updateProjectionMatrix()}function createEarth(){var a=100,b={Kr:.0025,Km:.001,ESun:20,g:-.95,innerRadius:a,cloudRadius:1.003*a,outerRadius:1.025*a,wavelength:[.65,.57,.475],scaleDepth:.25,mieScaleDepth:.1},c=THREE.ImageUtils.loadTexture("img/earth/EarthMapAtmos_2500x1250.jpg"),d=THREE.ImageUtils.loadTexture("img/earth/earthNight.jpg"),e=THREE.ImageUtils.loadTexture("img/earth/EarthMask_2500x1250.jpg"),f=THREE.ImageUtils.loadTexture("img/earth/cloudAlpha.png"),g=renderer.getMaxAnisotropy();c.anisotropy=g,d.anisotropy=g,e.anisotropy=g,f.anisotropy=g,uniforms={v3LightPosition:{type:"v3",value:new THREE.Vector3(1e8,0,0).normalize()},v3InvWavelength:{type:"v3",value:new THREE.Vector3(1/Math.pow(b.wavelength[0],4),1/Math.pow(b.wavelength[1],4),1/Math.pow(b.wavelength[2],4))},fCameraHeight:{type:"f",value:0},fCameraHeight2:{type:"f",value:0},fInnerRadius:{type:"f",value:b.innerRadius},fInnerRadius2:{type:"f",value:b.innerRadius*b.innerRadius},fCloudRadius:{type:"f",value:b.cloudRadius},fCloudRadius2:{type:"f",value:b.cloudRadius*b.cloudRadius},fOuterRadius:{type:"f",value:b.outerRadius},fOuterRadius2:{type:"f",value:b.outerRadius*b.outerRadius},fKrESun:{type:"f",value:b.Kr*b.ESun},fKmESun:{type:"f",value:b.Km*b.ESun},fKr4PI:{type:"f",value:4*b.Kr*Math.PI},fKm4PI:{type:"f",value:4*b.Km*Math.PI},fScale:{type:"f",value:1/(b.outerRadius-b.innerRadius)},fScaleDepth:{type:"f",value:b.scaleDepth},fScaleOverScaleDepth:{type:"f",value:1/(b.outerRadius-b.innerRadius)/b.scaleDepth},g:{type:"f",value:b.g},g2:{type:"f",value:b.g*b.g},nSamples:{type:"i",value:3},fSamples:{type:"f",value:3},tDiffuse:{type:"t",value:c},tDiffuseCloud:{type:"t",value:f},tDiffuseNight:{type:"t",value:d},tDisplacement:{type:"t",value:0},tSkyboxDiffuse:{type:"t",value:0},fNightScale:{type:"f",value:1},tSpecular:{type:"t",value:e}},ground={geometry:new THREE.SphereGeometry(b.innerRadius,50,50),material:new THREE.ShaderMaterial({uniforms:uniforms,vertexShader:vertexGround,fragmentShader:fragmentGround})},ground.mesh=new THREE.Mesh(ground.geometry,ground.material),ground.mesh.castShadow=!0,ground.mesh.receiveShadow=!0,scene.add(ground.mesh);var h=150;sky={geometry:new THREE.SphereGeometry(b.outerRadius,h,h),material:new THREE.ShaderMaterial({uniforms:uniforms,vertexShader:vertexSky,fragmentShader:fragmentSky})},sky.mesh=new THREE.Mesh(sky.geometry,sky.material),ground.mesh.castShadow=!0,ground.mesh.receiveShadow=!0,sky.material.side=THREE.BackSide,sky.material.transparent=!0,scene.add(sky.mesh),cloud={geometry:new THREE.SphereGeometry(b.cloudRadius,50,50),material:new THREE.ShaderMaterial({uniforms:uniforms,vertexShader:vertexCloud,fragmentShader:fragmentCloud})},cloud.mesh=new THREE.Mesh(cloud.geometry,cloud.material),cloud.material.transparent=!0,cloud.material.blending=THREE.AdditiveBlending,scene.add(cloud.mesh)}function createMoon(){moon={geometry:new THREE.SphereGeometry(27.2,32,32),material:new THREE.MeshLambertMaterial},moon.material.map=THREE.ImageUtils.loadTexture("img/moonmap.jpg"),moon.mesh=new THREE.Mesh(moon.geometry,moon.material),scene.add(moon.mesh),moon.mesh.position.set(0,0,0)}function createSatellite(){sat={geometry:new THREE.SphereGeometry(1,10,10),material:new THREE.MeshBasicMaterial({color:65280})},sat.mesh=new THREE.Mesh(sat.geometry,sat.material),scene.add(sat.mesh)}function createUniverse(){var a=THREE.ImageUtils.loadTexture("img/galaxy.jpg"),b={geometry:new THREE.SphereGeometry(5e5,32,32),material:new THREE.MeshBasicMaterial};b.material.map=a,b.material.side=THREE.BackSide,b.mesh=new THREE.Mesh(b.geometry,b.material),scene.add(b.mesh)}function createLensFlare(){var a=THREE.ImageUtils.loadTexture("img/lensflare/lensflare0.png"),b=THREE.ImageUtils.loadTexture("img/lensflare/lensflare2.png"),c=THREE.ImageUtils.loadTexture("img/lensflare/lensflare3.png"),d=new THREE.Color(16777215);d.setHSL(.55,.9,1),lensFlare=new THREE.LensFlare(a,700,0,THREE.AdditiveBlending,d),lensFlare.add(b,512,0,THREE.AdditiveBlending),lensFlare.add(b,512,0,THREE.AdditiveBlending),lensFlare.add(b,512,0,THREE.AdditiveBlending),lensFlare.add(c,60,.6,THREE.AdditiveBlending),lensFlare.add(c,70,.7,THREE.AdditiveBlending),lensFlare.add(c,120,.9,THREE.AdditiveBlending),lensFlare.add(c,70,1,THREE.AdditiveBlending),lensFlare.position.set(0,0,500),scene.add(lensFlare)}function setXYZ(){var a=new THREE.LineBasicMaterial({color:11862037}),b=new THREE.Geometry;b.vertices.push(new THREE.Vector3(0,0,0));var c=new Date,d=c.getMonth()+1,e={1:-23.44,2:-15.53,3:-7.62,4:.29,5:7.62,6:15.53,7:23.44,8:15.53,9:7.62,10:-.29,11:-7.62,12:-15.53},f=e[d],g=24e4*Math.cos(2*f*Math.PI/360),h=24e4*Math.sin(2*f*Math.PI/360),i=0;b.vertices.push(new THREE.Vector3(g,h,i));var j=new THREE.Line(b,a);scene.add(j);var k=new THREE.LineBasicMaterial({color:11862037}),l=new THREE.Geometry;l.vertices.push(new THREE.Vector3(0,0,0)),l.vertices.push(new THREE.Vector3(150,0,0));var g=new THREE.Line(l,k);scene.add(g);var m=new THREE.LineBasicMaterial({color:817664}),n=new THREE.Geometry;n.vertices.push(new THREE.Vector3(0,0,0)),n.vertices.push(new THREE.Vector3(0,150,0));var h=new THREE.Line(n,m);scene.add(h);var o=new THREE.LineBasicMaterial({color:327836}),p=new THREE.Geometry;p.vertices.push(new THREE.Vector3(0,0,0)),p.vertices.push(new THREE.Vector3(0,0,150));var i=new THREE.Line(p,o);scene.add(i)}function updateEarthAngle(){var a=Math.PI/12,b=a/60/60,c=new Date,d=new Date(c.valueOf()+6e4*c.getTimezoneOffset()),e=d.getMinutes(),f=d.getHours(),g=d.getSeconds(),h=g+60*e+60*f*60,i=Math.PI-b*h;eurlerLight=new THREE.Euler(0,i,0);var j=getTodayEarthAngle(),k=i+Math.PI/2,l=24e4*Math.sin(k),m=24e4*Math.cos(k),n=24e4*Math.sin(2*j*Math.PI/360);lensFlare.position.set(l,n,m),sun.position.set(l,n,m),setTimeout(updateEarthAngle,3e3)}function getTodayEarthAngle(){var a=new Date,b=new Date(a.getFullYear(),0,0),c=a-b,d=864e5,e=Math.floor(c/d),f=Math.asin(Math.sin(23.45*(Math.PI/180))*Math.sin(360/365*(e-81)*(Math.PI/180))),g=180*f/Math.PI;return g}function render(){var a,b,c,d;requestAnimationFrame(render),controls.update();var e=getTodayEarthAngle(),f=Math.sin(2*e*Math.PI/360);return d=new THREE.Vector3(1,f,0),c=(new THREE.Matrix4).makeRotationFromEuler(eurlerLight),b=d.applyProjection(c),a=camera.position.length(),sky.material.uniforms.v3LightPosition.value=b,sky.material.uniforms.fCameraHeight.value=a,sky.material.uniforms.fCameraHeight2.value=a*a,ground.material.uniforms.v3LightPosition.value=b,ground.material.uniforms.fCameraHeight.value=a,ground.material.uniforms.fCameraHeight2.value=a*a,cloud.material.uniforms.v3LightPosition.value=b,cloud.material.uniforms.fCameraHeight.value=a,cloud.material.uniforms.fCameraHeight2.value=a*a,renderer.render(scene,camera)}function drawOrbit(a){var b=new THREE.LineBasicMaterial({color:11862037}),c=new THREE.Geometry;for(var d in a)c.vertices.push(new THREE.Vector3(a[d].x,a[d].y,a[d].z));var e=new THREE.Line(c,b);scene.add(e)}function updateSatPosition(){if(earthPositionData){var a=interpolatePosition(earthPositionData,earthReceivedDate);sat.mesh.position.set(a.x,a.y,a.z)}setTimeout(updateSatPosition,100)}function satPosition(a){earthPositionData=a,earthReceivedDate=new Date,sat.mesh.position.set(a[0].x,a[0].y,a[0].z),drawOrbit(a)}function moonPosition(a){moonPositionData=a,moonReceivedDate=new Date,moon.mesh.position.set(a[0].x,a[0].y,a[0].z)}function updateMoonPosition(){if(moonPositionData){var a=interpolatePosition(moonPositionData,moonReceivedDate);moon.mesh.position.set(a.x,a.y,a.z)}setTimeout(updateMoonPosition,200)}function interpolatePosition(a,b){var c=(new Date(a[0].time),new Date),d=c.getSeconds(),e=c.getMilliseconds(),f=c.getMinutes()-b.getMinutes(),g=60*(c.getHours()-b.getHours());f+=g;var h=a[f],i=a[f+1];h||(console.error("No data for current"),console.log(f),console.log(h)),i||(console.error("No data for next"),console.log(f+1),console.log(i));var j=(i.x-h.x)/60,k=(i.y-h.y)/60,l=(i.z-h.z)/60,m=j/1e3,n=k/1e3,o=l/1e3,p={};return p.x=h.x+j*d+m*e,p.y=h.y+k*d+n*e,p.z=h.z+l*d+o*e,p}function bindScrollBtn(a){document.getElementById("btn-bottom").onclick=function(){scrollTo(document.body,a,500)}}function setImg(a){document.getElementById("img-scroll").src="img/"+a}function scrollTo(a,b,c){var d=a.scrollTop,e=b-d,f=0,g=20,h=function(){f+=g;var b=Math.easeInOutQuad(f,d,e,c);a.scrollTop=b,c>f&&setTimeout(h,g)};h()}var vertexSky="//\n// Atmospheric scattering vertex shader\n//\n// Author: Sean O'Neil\n//\n// Copyright (c) 2004 Sean O'Neil\n//\nuniform vec3 v3LightPosition;	// The direction vector to the light source\nuniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;	// The camera's current height\nuniform float fCameraHeight2;	// fCameraHeight^2\nuniform float fOuterRadius;		// The outer (atmosphere) radius\nuniform float fOuterRadius2;	// fOuterRadius^2\nuniform float fInnerRadius;		// The inner (planetary) radius\nuniform float fInnerRadius2;	// fInnerRadius^2\nuniform float fKrESun;			// Kr * ESun\nuniform float fKmESun;			// Km * ESun\nuniform float fKr4PI;			// Kr * 4 * PI\nuniform float fKm4PI;			// Km * 4 * PI\nuniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\n\nfloat scale(float fCos)\n{\n    float x = 1.0 - fCos;\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void)\n{\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n    vec3 v3Ray = position - cameraPosition;\n    float fFar = length(v3Ray);\n    v3Ray /= fFar;\n\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n    float B = 2.0 * dot(cameraPosition, v3Ray);\n    float C = fCameraHeight2 - fOuterRadius2;\n    float fDet = max(0.0, B*B - 4.0 * C);\n    float fNear = 0.5 * (-B - sqrt(fDet));\n\n    // Calculate the ray's starting position, then calculate its scattering offset\n    vec3 v3Start = cameraPosition + v3Ray * fNear;\n    fFar -= fNear;\n    float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n    float fStartDepth = exp(-1.0 / fScaleDepth);\n    float fStartOffset = fStartDepth * scale(fStartAngle);\n    //c0 = vec3(1.0, 0, 0) * fStartAngle;\n\n    // Initialize the scattering loop variables\n    float fSampleLength = fFar / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = v3Ray * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n    //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\n\n    // Now loop through the sample rays\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<nSamples; i++)\n    {\n        float fHeight = length(v3SamplePoint);\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n        float fLightAngle = dot(v3LightPosition, v3SamplePoint) / fHeight;\n        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n        float fScatter = (fStartOffset + fDepth * (scale(fLightAngle) - scale(fCameraAngle)));\n        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n        v3SamplePoint += v3SampleRay;\n    }\n\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    c0 = v3FrontColor * (v3InvWavelength * fKrESun);\n    c1 = v3FrontColor * fKmESun;\n    v3Direction = cameraPosition - position;\n}",fragmentSky="//\n    // Atmospheric scattering fragment shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n\n    uniform vec3 v3LightPos;\n    uniform float g;\n    uniform float g2;\n\n    varying vec3 v3Direction;\n    varying vec3 c0;\n    varying vec3 c1;\n\n    // Calculates the Mie phase function\n    float getMiePhase(float fCos, float fCos2, float g, float g2)\n    {\n        return 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(1.0 + g2 - 2.0 * g * fCos, 1.5);\n    }\n\n    // Calculates the Rayleigh phase function\n    float getRayleighPhase(float fCos2)\n    {\n        return 0.75 + 0.75 * fCos2;\n    }\n\n    void main (void)\n    {\n        float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);\n        float fCos2 = fCos * fCos;\n\n        vec3 color =	getRayleighPhase(fCos2) * c0 +\n                        getMiePhase(fCos, fCos2, g, g2) * c1;\n\n        gl_FragColor = vec4(color, 1.0);\n        gl_FragColor.a = gl_FragColor.b;\n   }",vertexGround="//\n    // Atmospheric scattering vertex shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // Ported for use with three.js/WebGL by James Baicoianu\n\n    uniform vec3 v3LightPosition;		// The direction vector to the light source\n    uniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\n    uniform float fCameraHeight;	// The camera's current height\n    uniform float fCameraHeight2;	// fCameraHeight^2\n    uniform float fOuterRadius;		// The outer (atmosphere) radius\n    uniform float fOuterRadius2;	// fOuterRadius^2\n    uniform float fInnerRadius;		// The inner (planetary) radius\n    uniform float fInnerRadius2;	// fInnerRadius^2\n    uniform float fKrESun;			// Kr * ESun\n    uniform float fKmESun;			// Km * ESun\n    uniform float fKr4PI;			// Kr * 4 * PI\n    uniform float fKm4PI;			// Km * 4 * PI\n    uniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\n    uniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n    uniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\n    uniform sampler2D tDiffuse;\n\n    varying vec3 v3Direction;\n    varying vec3 c0;\n    varying vec3 c1;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec2 testCoord;\n\n    const int nSamples = 3;\n    const float fSamples = 3.0;\n\n    float scale(float fCos)\n    {\n        float x = 1.0 - fCos;\n        return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n    }\n\n    void main(void)\n    {\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = position - cameraPosition;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n        // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n        float B = 2.0 * dot(cameraPosition, v3Ray);\n        float C = fCameraHeight2 - fOuterRadius2;\n        float fDet = max(0.0, B*B - 4.0 * C);\n        float fNear = 0.5 * (-B - sqrt(fDet));\n\n        // Calculate the ray's starting position, then calculate its scattering offset\n        vec3 v3Start = cameraPosition + v3Ray * fNear;\n        fFar -= fNear;\n        float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n        float fCameraAngle = dot(-v3Ray, position) / length(position);\n        float fLightAngle = dot(v3LightPosition, position) / length(position);\n        float fCameraScale = scale(fCameraAngle);\n        float fLightScale = scale(fLightAngle);\n        float fCameraOffset = fDepth*fCameraScale;\n        float fTemp = (fLightScale + fCameraScale);\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n        vec3 v3Attenuate;\n        for(int i=0; i<nSamples; i++)\n        {\n            float fHeight = length(v3SamplePoint);\n            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n            float fScatter = fDepth*fTemp - fCameraOffset;\n            v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n            v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n            v3SamplePoint += v3SampleRay;\n        }\n\n        // Calculate the attenuation factor for the ground\n        c0 = v3Attenuate;\n        c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      //testCoord = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n        //gl_TexCoord[0] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n        //gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n      vUv = uv;\n      vNormal = normal;\n    }",fragmentGround="//\n    // Atmospheric scattering fragment shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // Ported for use with three.js/WebGL by James Baicoianu\n\n    uniform float fNightScale;\n    uniform vec3 v3LightPosition;\n    uniform sampler2D tDiffuse;\n    uniform sampler2D tDiffuseNight;\n    uniform sampler2D tSpecular;\n\n\n    varying vec3 c0;\n    varying vec3 c1;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 v3Direction;\n\n    void main (void)\n    {\n        //Spope\n        /*\n        float shininess = (texture2D(tSpecular, vec2(vUv.s, vUv.t)).r * 255.0) + 0.1; // Apparament incorect > le pow() a besoin d'une virgule\n        vec3 reflectionDirection = reflect(-v3LightPosition, vNormal);\n        float specularLightWeighting;\n        specularLightWeighting = pow(max(dot(reflectionDirection, v3Direction), 0.0), shininess);//Shininess 20\n\n        float diffuseLightWeighting = max(dot(vNormal, v3LightPosition), 0.0);\n\n        vec3 uAmbientColor = vec3(1, 1, 1);\n        vec3 uPointLightingSpecularColor = vec3(1, 1, 1);\n        vec3 uPointLightingDiffuseColor = vec3(1, 1, 1);\n\n        vec3 lightWeighting = uAmbientColor\n        + uPointLightingSpecularColor * specularLightWeighting\n        + uPointLightingDiffuseColor * diffuseLightWeighting;\n        \n\n        //vec3 lightWeighting = vec3(1, 1, 1);\n\n        vec4 fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);\n        vec4 temp = vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a);\n\n        //float mid = 0.5;\n        //float vRotation = 1.57;\n        //vec2 rotated = vec2(cos(vRotation) * (gl_PointCoord.x - mid) + sin(vRotation) * (gl_PointCoord.y - mid) + mid,\n            //cos(vRotation) * (gl_PointCoord.y - mid) - sin(vRotation) * (gl_PointCoord.x - mid) + mid);\n\n\n        vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;\n        vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;\n\n        vec3 day = diffuseTex * c0;\n        vec3 night = fNightScale * diffuseNightTex * diffuseNightTex * diffuseNightTex * (1.0 - c0);\n\n        gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);\n        */\n\n        vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;\n        vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;\n\n        vec3 day = diffuseTex * c0;\n        vec3 night = fNightScale * diffuseNightTex * diffuseNightTex * diffuseNightTex * (1.0 - c0);\n\n        gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);\n\n        //ORIGINAL\n        /*\n        vec3 diffuseTex = texture2D( tDiffuse, vUv ).xyz;\n        vec3 diffuseNightTex = texture2D( tDiffuseNight, vUv ).xyz;\n\n        vec3 day = diffuseTex * c0;\n        vec3 night = fNightScale * diffuseNightTex * diffuseNightTex * diffuseNightTex * (1.0 - c0);\n\n        gl_FragColor = vec4(c1, 1.0) + vec4(day + night, 1.0);\n        */\n    }",vertexCloud="//\n    // Atmospheric scattering vertex shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // Ported for use with three.js/WebGL by James Baicoianu\n\n    uniform vec3 v3LightPosition;		// The direction vector to the light source\n    uniform vec3 v3InvWavelength;	// 1 / pow(wavelength, 4) for the red, green, and blue channels\n    uniform float fCameraHeight;	// The camera's current height\n    uniform float fCameraHeight2;	// fCameraHeight^2\n    uniform float fOuterRadius;		// The outer (atmosphere) radius\n    uniform float fOuterRadius2;	// fOuterRadius^2\n    uniform float fCloudRadius;		// The inner (planetary) radius\n    uniform float fCloudRadius2;	// fInnerRadius^2\n    uniform float fKrESun;			// Kr * ESun\n    uniform float fKmESun;			// Km * ESun\n    uniform float fKr4PI;			// Kr * 4 * PI\n    uniform float fKm4PI;			// Km * 4 * PI\n    uniform float fScale;			// 1 / (fOuterRadius - fInnerRadius)\n    uniform float fScaleDepth;		// The scale depth (i.e. the altitude at which the atmosphere's average density is found)\n    uniform float fScaleOverScaleDepth;	// fScale / fScaleDepth\n    uniform sampler2D tDiffuseCloud;\n\n    varying vec3 v3Direction;\n    varying vec3 c0;\n    varying vec3 c1;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec2 testCoord;\n\n    const int nSamples = 3;\n    const float fSamples = 3.0;\n\n    float scale(float fCos)\n    {\n        float x = 1.0 - fCos;\n        return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n    }\n\n    void main(void)\n    {\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = position - cameraPosition;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n        // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n        float B = 2.0 * dot(cameraPosition, v3Ray);\n        float C = fCameraHeight2 - fOuterRadius2;\n        float fDet = max(0.0, B*B - 4.0 * C);\n        float fNear = 0.5 * (-B - sqrt(fDet));\n\n        // Calculate the ray's starting position, then calculate its scattering offset\n        vec3 v3Start = cameraPosition + v3Ray * fNear;\n        fFar -= fNear;\n        float fDepth = exp((fCloudRadius - fOuterRadius) / fScaleDepth);\n        float fCameraAngle = dot(-v3Ray, position) / length(position);\n        float fLightAngle = dot(v3LightPosition, position) / length(position);\n        float fCameraScale = scale(fCameraAngle);\n        float fLightScale = scale(fLightAngle);\n        float fCameraOffset = fDepth*fCameraScale;\n        float fTemp = (fLightScale + fCameraScale);\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n        vec3 v3Attenuate;\n        for(int i=0; i<nSamples; i++)\n        {\n            float fHeight = length(v3SamplePoint);\n            float fDepth = exp(fScaleOverScaleDepth * (fCloudRadius - fHeight));\n            float fScatter = fDepth*fTemp - fCameraOffset;\n            v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n            v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n            v3SamplePoint += v3SampleRay;\n        }\n\n        // Calculate the attenuation factor for the ground\n        c0 = v3Attenuate;\n        c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n      //testCoord = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n        //gl_TexCoord[0] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n        //gl_TexCoord[1] = gl_TextureMatrix[1] * gl_MultiTexCoord1;\n      vUv = uv;\n      vNormal = normal;\n    }",fragmentCloud="//\n    // Atmospheric scattering fragment shader\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // Ported for use with three.js/WebGL by James Baicoianu\n\n    //uniform sampler2D s2Tex1;\n    //uniform sampler2D s2Tex2;\n\n    uniform float fNightScale;\n    uniform vec3 v3LightPosition;\n    uniform sampler2D tDiffuseCloud;\n\n    varying vec3 c0;\n    varying vec3 c1;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 v3Direction;\n\n    void main (void)\n    {\n        //gl_FragColor = vec4(c0, 1.0);\n        //gl_FragColor = vec4(0.25 * c0, 1.0);\n        //gl_FragColor = gl_Color + texture2D(s2Tex1, gl_TexCoord[0].st) * texture2D(s2Tex2, gl_TexCoord[1].st) * gl_SecondaryColor;\n\n        vec3 diffuseTex = texture2D( tDiffuseCloud, vUv ).xyz;\n\n        vec3 dayCloud = diffuseTex * c0;\n\n        gl_FragColor = vec4(dayCloud, 1.0);\n    }",nasaRequest=function(a){var b="Geo",c=start.toISOString(),d=end.toISOString(),e='<?xml version="1.0" encoding="UTF-8" standalone="yes"?><DataRequest xmlns="http://sscweb.gsfc.nasa.gov/schema">',f='<BFieldModel><InternalBFieldModel>IGRF-10</InternalBFieldModel><ExternalBFieldModel xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Tsyganenko89cBFieldModel"><KeyParameterValues>KP3_3_3</KeyParameterValues></ExternalBFieldModel><TraceStopAltitude>100</TraceStopAltitude></BFieldModel>',g="<OutputOptions><AllLocationFilters>true</AllLocationFilters><CoordinateOptions><CoordinateSystem>"+b+"</CoordinateSystem><Component>X</Component></CoordinateOptions><CoordinateOptions><CoordinateSystem>"+b+"</CoordinateSystem><Component>Y</Component></CoordinateOptions><CoordinateOptions><CoordinateSystem>"+b+"</CoordinateSystem><Component>Z</Component></CoordinateOptions><MinMaxPoints>2</MinMaxPoints></OutputOptions></DataRequest>",h="<TimeInterval><Start>"+c+"</Start><End>"+d+"</End></TimeInterval>",i="<Satellites><Id>"+a+"</Id><ResolutionFactor>1</ResolutionFactor></Satellites>";return e+h+f+i+g},GetPosition=function(a,b,c,d){this.satId=a,this.earthRadiusKm=63.78,this.sscUrl="http://sscweb.gsfc.nasa.gov/WS/sscr/2/locations",this.callback=d};GetPosition.prototype.request=function(){var a=nasaRequest(this.satId,this.start,this.end);$.ajax({type:"POST",url:this.sscUrl+"",data:a,dataType:"xml",contentType:"application/xml",processData:!1,success:this.displayData.bind(this),error:this.dataError})},GetPosition.prototype.displayData=function(a){var b=$(a).find("StatusCode").text();return"Success"!=b?void alert("Request for information from SSC failed."):(a=$.xml2json(a),void this.displaySatelliteTrajectory(a))},GetPosition.prototype.displaySatelliteTrajectory=function(a){var b={},c=a.Result.Data.Time,d=a.Result.Data.Coordinates.X,e=a.Result.Data.Coordinates.Y,f=a.Result.Data.Coordinates.Z;for(var g in c)b[g]={time:c[g],x:d[g]/this.earthRadiusKm,y:f[g]/this.earthRadiusKm,z:-(e[g]/this.earthRadiusKm)};this.callback(b)},GetPosition.prototype.dataError=function(a,b,c){var d=$.parseXML(a.responseText),e=$(d).find(".ErrorMessage").text(),f=$(d).find(".ErrorDescription").text();alert("Server request error:\n  HTTP error: "+c+"\n  "+e+"\n  "+f)};var start=new Date,end=new Date;end=new Date(end.getTime()+1104e4),$(function(){var a=new GetPosition("iss",start,end,satPosition);a.request();var b=new GetPosition("moon",start,end,moonPosition);b.request()});var camera,render,renderer,scene,uniforms,controls,earthPositionData,earthReceivedDate,moon,moonPositionData,moonReceivedDate,lensFlare,eurlerLight,ground,sky,cloud,sat,sun;initScene();var body=document.body,html=document.documentElement,height=Math.max(body.scrollHeight,body.offsetHeight,html.clientHeight,html.scrollHeight,html.offsetHeight);bindScrollBtn(height),window.onscroll=function(){document.body.scrollTop>1?(bindScrollBtn(0),setImg("up.png")):(bindScrollBtn(height),setImg("bottom.png"))},Math.easeInOutQuad=function(a,b,c,d){return a/=d/2,1>a?c/2*a*a+b:(a--,-c/2*(a*(a-2)-1)+b)};